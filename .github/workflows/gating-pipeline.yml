name: CI/CD Security Gating Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      override_gates:
        description: 'Override security gates (requires approval)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      user_role:
        description: 'User role for testing (configure in Permit.io)'
        required: false
        default: 'ci-pipeline'
        type: choice
        options:
          - 'ci-pipeline'
          - 'developer'
          - 'editor'
          - 'security-admin'

env:
  JAVA_VERSION: '11'
  MAVEN_VERSION: '3.8.6'
  DOCKER_BUILDKIT: 1
  PDP_URL: http://localhost:7766

jobs:
  build-and-scan:
    name: Build and Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          
      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-
            
      - name: Build Spring Boot application
        run: |
          cd microservice-moc-app
          mvn clean compile
          
      - name: Validate Snyk configuration
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
          SNYK_ORG_ID: ${{ secrets.SNYK_ORG_ID }}
        run: |
          # Make validation script executable and run it
          chmod +x snyk-scanning/scripts/validate-snyk.sh
          ./snyk-scanning/scripts/validate-snyk.sh

      - name: Run Snyk security scan
        id: snyk_scan
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
          SNYK_ORG_ID: ${{ secrets.SNYK_ORG_ID }}
        run: |
          # Install Snyk CLI
          npm install -g snyk
          
          # Authenticate with Snyk
          snyk auth $SNYK_TOKEN
          
          # Ensure results directory exists
          mkdir -p snyk-scanning/results
          
          # Run Snyk test and capture results
          cd microservice-moc-app
          
          # Run test and save results (allow failure to capture vulnerabilities)
          snyk test --json > ../snyk-scanning/results/snyk-results.json || true
          
          # Parse results for summary
          echo "Snyk scan completed. Parsing results..."
          
          # Extract vulnerability counts with better error handling
          CRITICAL_COUNT=$(jq '.vulnerabilities | map(select(.severity == "critical")) | length // 0' ../snyk-scanning/results/snyk-results.json)
          HIGH_COUNT=$(jq '.vulnerabilities | map(select(.severity == "high")) | length // 0' ../snyk-scanning/results/snyk-results.json)
          MEDIUM_COUNT=$(jq '.vulnerabilities | map(select(.severity == "medium")) | length // 0' ../snyk-scanning/results/snyk-results.json)
          LOW_COUNT=$(jq '.vulnerabilities | map(select(.severity == "low")) | length // 0' ../snyk-scanning/results/snyk-results.json)
          
          echo "CRITICAL_COUNT=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
          echo "HIGH_COUNT=$HIGH_COUNT" >> $GITHUB_OUTPUT
          echo "MEDIUM_COUNT=$MEDIUM_COUNT" >> $GITHUB_OUTPUT
          echo "LOW_COUNT=$LOW_COUNT" >> $GITHUB_OUTPUT
          
          # Display summary
          echo "## Vulnerability Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Critical: $CRITICAL_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- High: $HIGH_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- Medium: $MEDIUM_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- Low: $LOW_COUNT" >> $GITHUB_STEP_SUMMARY
          
      - name: Send results to Snyk UI (Monitor)
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          cd microservice-moc-app
          
          # Send results to Snyk dashboard with project name
          echo "ðŸ“¤ Sending scan results to Snyk dashboard..."
          snyk monitor --project-name="cicd-pipeline-poc/microservice-moc-app-deps" || true
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Snyk Dashboard" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Dependency scan results sent to [Snyk Dashboard](https://app.snyk.io)" >> $GITHUB_STEP_SUMMARY
          echo "Project: cicd-pipeline-poc/microservice-moc-app-deps" >> $GITHUB_STEP_SUMMARY
          
      - name: Run Snyk Code Analysis (SAST)
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          cd microservice-moc-app
          
          echo "ðŸ” Running Snyk Code analysis for security issues in source code..."
          
          # Run Snyk Code test (SAST) - this doesn't affect our JSON file
          snyk code test --json > ../snyk-scanning/results/snyk-code-results.json || true
          
          # Parse SAST results for summary
          if [ -f "../snyk-scanning/results/snyk-code-results.json" ]; then
            SAST_HIGH=$(jq '.runs[0].results | map(select(.level == "error")) | length // 0' ../snyk-scanning/results/snyk-code-results.json 2>/dev/null || echo "0")
            SAST_MEDIUM=$(jq '.runs[0].results | map(select(.level == "warning")) | length // 0' ../snyk-scanning/results/snyk-code-results.json 2>/dev/null || echo "0")
            SAST_LOW=$(jq '.runs[0].results | map(select(.level == "note")) | length // 0' ../snyk-scanning/results/snyk-code-results.json 2>/dev/null || echo "0")
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ”’ Code Security Analysis (SAST)" >> $GITHUB_STEP_SUMMARY
            echo "- High: $SAST_HIGH" >> $GITHUB_STEP_SUMMARY
            echo "- Medium: $SAST_MEDIUM" >> $GITHUB_STEP_SUMMARY
            echo "- Low: $SAST_LOW" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Build and scan Docker image
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          # Build Docker image
          cd microservice-moc-app
          docker build -t cicd-poc-app:scan .
          
          # Scan Docker image with Snyk
          echo "ðŸ³ Scanning Docker image for vulnerabilities..."
          snyk container test cicd-poc-app:scan --json > ../snyk-scanning/results/snyk-container-results.json || true
          
          # Send container results to Snyk UI
          snyk container monitor cicd-poc-app:scan --project-name="cicd-pipeline-poc/microservice-moc-app-container" || true
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ³ Container Security" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Container scan results sent to [Snyk Dashboard](https://app.snyk.io)" >> $GITHUB_STEP_SUMMARY
          echo "Project: cicd-pipeline-poc/microservice-moc-app-container" >> $GITHUB_STEP_SUMMARY
          
      - name: Upload Snyk results
        uses: actions/upload-artifact@v4
        with:
          name: snyk-results
          path: |
            snyk-scanning/results/snyk-results.json
            snyk-scanning/results/snyk-code-results.json
            snyk-scanning/results/snyk-container-results.json
          
  security-gates:
    name: Security Gate Evaluation
    runs-on: ubuntu-latest
    needs: build-and-scan
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download Snyk results
        uses: actions/download-artifact@v4
        with:
          name: snyk-results
          path: snyk-scanning/results
          
      - name: Install jq for JSON parsing
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Validate Permit.io configuration
        env:
          PERMIT_API_KEY: ${{ secrets.PERMIT_API_KEY }}
        run: |
          # Make validation script executable and run it
          chmod +x permit-gating/scripts/validate-permit.sh
          ./permit-gating/scripts/validate-permit.sh

      - name: Start Docker Compose services
        env:
          PERMIT_API_KEY: ${{ secrets.PERMIT_API_KEY }}
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
          SNYK_ORG_ID: ${{ secrets.SNYK_ORG_ID }}
          USER_KEY: ${{ github.actor }}
          USER_ROLE: ${{ github.event.inputs.user_role || 'editor' }}
        run: |
          # Create .env file only for Docker Compose (required by docker-compose.yml)
          cat > .env << EOF
          PERMIT_API_KEY=$PERMIT_API_KEY
          SNYK_TOKEN=$SNYK_TOKEN
          SNYK_ORG_ID=$SNYK_ORG_ID
          USER_KEY=${USER_KEY}
          USER_ROLE=${USER_ROLE}
          EOF
          
          # Start Docker Compose services
          docker compose up -d --build
          
          # Wait for services to be ready with better health checks
          echo "Waiting for services to start..."
          sleep 30  # Increased from 15 to 30 seconds for better sync
          
          # Check service health using multiple endpoints like the working scripts
          echo "Checking service health..."
          
          # Check PDP health on correct port
          for i in {1..10}; do
            if curl -sf http://localhost:7001/healthy > /dev/null 2>&1; then
              echo "âœ“ PDP health endpoint is responding"
              break
            elif [ $i -eq 10 ]; then
              echo "âœ— PDP failed to become ready"
              docker compose logs permit-pdp
              exit 1
            else
              echo "Attempt $i/10: PDP not ready yet..."
              sleep 3
            fi
          done
          
          # Verify PDP is fully synced with Permit.io cloud
          echo "Verifying PDP sync with Permit.io cloud..."
          for i in {1..20}; do
            response=$(curl -s -X POST http://localhost:7766/allowed \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $PERMIT_API_KEY" \
              -d '{"user":{"key":"david-santander","attributes":{"role":"editor"}},"action":"test","resource":{"type":"deployment","key":"sync-test","attributes":{}}}' 2>/dev/null || echo "{}")
            
            if echo "$response" | grep -q '"synced":true'; then
              echo "âœ“ PDP is fully synced with Permit.io cloud"
              echo "  User david-santander is synchronized"
              break
            elif [ $i -eq 20 ]; then
              echo "âš ï¸ PDP sync verification timeout - proceeding anyway"
              echo "  This may affect audit logging"
            else
              echo "  Waiting for PDP to sync with cloud... ($i/20)"
              sleep 3
            fi
          done
          
          # Test network connectivity to Permit.io cloud
          echo "Testing connectivity to Permit.io cloud..."
          if curl -sf -o /dev/null -w "%{http_code}" https://api.permit.io/v2/projects \
             -H "Authorization: Bearer $PERMIT_API_KEY" | grep -q "200"; then
            echo "âœ“ Successfully connected to Permit.io cloud API"
          else
            echo "âš ï¸ Could not verify connection to Permit.io cloud"
            echo "  This may affect audit logging"
          fi
          
          # Check PDP container logs for any connection issues
          echo "Checking PDP container status..."
          docker compose exec -T permit-pdp wget -q -O - http://localhost:7001/healthy || echo "PDP health check status: $?"
          
      - name: Debug User Context
        run: |
          echo "ðŸ” GitHub Context Debug:"
          echo "  GitHub Actor: ${{ github.actor }}"
          echo "  GitHub Event Actor: ${{ github.event.actor.login }}"
          echo "  GitHub Repository Owner: ${{ github.repository_owner }}"
          echo "  GitHub Repository: ${{ github.repository }}"
          echo "  User Role Input: ${{ github.event.inputs.user_role }}"
          
      - name: Evaluate Security Gates
        id: gate_evaluation
        env:
          PDP_URL: ${{ env.PDP_URL }}
          PERMIT_API_KEY: ${{ secrets.PERMIT_API_KEY }}
          USER_KEY: ${{ github.actor }}  # Use GitHub username for Permit.io audit logs
          USER_ROLE: ${{ github.event.inputs.user_role || 'editor' }}  # Use input role or default to editor for testing
        run: |
          echo "ðŸ” Evaluating security gates:"
          echo "  Permit.io User Key: ${USER_KEY}"
          echo "  Permit.io User Role: ${USER_ROLE}"
          echo "  GitHub Actor: ${{ github.actor }}"
          echo "  Expected in audit logs: User=${USER_KEY}, Action=deploy"
          echo ""
          # Run gate evaluation script with proper environment
          chmod +x permit-gating/scripts/evaluate-gates.sh
          
          # Disable exit on error temporarily to capture exit code
          set +e
          ./permit-gating/scripts/evaluate-gates.sh snyk-scanning/results/snyk-results.json
          
          # Capture exit code
          GATE_RESULT=$?
          echo "GATE_RESULT=$GATE_RESULT" >> $GITHUB_OUTPUT
          
          # Re-enable exit on error
          set -e
          
          # Wait for audit logs to be sent to Permit.io cloud
          echo "Waiting for audit logs to be sent to Permit.io..."
          sleep 10
          
          # Check PDP logs for audit log confirmation
          echo "Checking PDP logs for audit activity..."
          docker compose logs permit-pdp --tail=20 | grep -i "audit\|log" || echo "No audit log entries found in recent logs"
          
          # Set job status based on gate result with enhanced messaging
          case $GATE_RESULT in
            0)
              echo "âœ… All security gates passed" >> $GITHUB_STEP_SUMMARY
              echo "ðŸŽ‰ No blocking vulnerabilities found. Deployment can proceed." >> $GITHUB_STEP_SUMMARY
              exit 0
              ;;
            1)
              echo "âš ï¸ Soft gate warnings - proceeding with caution" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ“‹ Non-blocking vulnerabilities detected. Review recommended." >> $GITHUB_STEP_SUMMARY
              exit 0  # Treat soft gate warnings as success to continue pipeline
              ;;
            2)
              echo "âŒ Hard gate failed - deployment blocked" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ›‘ Critical vulnerabilities must be resolved before deployment." >> $GITHUB_STEP_SUMMARY
              if [ "${{ github.event.inputs.override_gates }}" != "true" ]; then
                exit 2
              else
                echo "âš ï¸ Gates overridden by user" >> $GITHUB_STEP_SUMMARY
                exit 0  # Override allows pipeline to continue
              fi
              ;;
            *)
              echo "â“ Unexpected gate evaluation result (exit code: $GATE_RESULT)" >> $GITHUB_STEP_SUMMARY
              exit 2
              ;;
          esac
          
      - name: Stop Docker Compose services
        if: always()
        run: |
          docker compose down
          
  build-docker-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: security-gates
    if: success() || (github.event.inputs.override_gates == 'true')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Build Docker image
        run: |
          cd microservice-moc-app
          docker build -t gating-poc-app:${{ github.sha }} .
          
      - name: Save Docker image
        run: |
          docker save gating-poc-app:${{ github.sha }} > gating-poc-app.tar
          
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: gating-poc-app.tar
          
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: build-docker-image
    if: github.ref == 'refs/heads/main' && (success() || github.event.inputs.override_gates == 'true')
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          
      - name: Load Docker image
        run: |
          docker load < gating-poc-app.tar
          
      - name: Deploy to environment
        run: |
          echo "ðŸš€ Deploying application version ${{ github.sha }}"
          # Add actual deployment steps here
          # For PoC, we'll just run the container locally
          docker run -d -p 8080:8080 --name gating-poc-app gating-poc-app:${{ github.sha }}
          
          # Wait for application to start
          sleep 10
          
          # Health check
          curl -f http://localhost:8080/actuator/health || exit 1
          
          echo "âœ… Deployment successful" >> $GITHUB_STEP_SUMMARY
          
      - name: Cleanup
        if: always()
        run: |
          docker stop gating-poc-app || true
          docker rm gating-poc-app || true